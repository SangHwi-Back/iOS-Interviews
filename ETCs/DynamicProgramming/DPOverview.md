# Dynamic Programming이란?

동적 프로그래밍은 분할정복 기법에 기반하여 부분 문제의 해를 결합하여 전체 문제를 해결하는 방식을 말한다.

간단히 분할정복 알고리즘에 대해 설명하자면 서로 겹치지 않는 (disjoint) 부분 문제로 해결한 뒤 결합하여 원래 문제를 해결하는 것을 말한다.

동적 프로그래밍은 이와 약간 다른데, 부분 문제가 서로 중복될 때 (부분 문제가 다시 자신의 부분 문제를 공유할 때) 필요 이상의 업무를 줄일 수 있도록 테이블에 저장하는 부분이 다르다. 각 부분 문제를 풀 때마다 다시 계산하는 일을 피할 수 있다.

주로 최적화 문제 해결이 필요할 때 동적 프로그래밍을 사용한다. 이런 종류의 문제는 최적의 해를 찾기를 원하는데 주로 최소/최대값을 물어보는 경우가 많다. 이런 해는 문제에 대한 유일한 해답이 아니기 때문에 한 개의 최적해라 한다. 동적 프로그래밍 알고리즘을 개발할 때는 다음 4단계를 따른다.

1. 최적해의 구조의 특징을 찾는다.
2. 최적해의 값을 재귀적으로 정의한다.
3. 최적해의 값을 일반적으로 상향식(bottom-up) 방법으로 계산한다.
4. 계산된 정보들로부터 최적해를 구성한다.

1~3 단계는 주어진 한 문제에 대한 동적 프로그래밍 해의 기초가 된다. 4 단계는 최적해 자체는 필요 없고 최적해의 값만 필요할 경우 생략 가능하다. 4단계의 최적해를 구성하기 위해 3단계의 부가적인 정보를 유지하기도 한다.

## 최적화 문제 1 - 막대기 자르기

<문제> 강철 회사는 강철 막대를 사서 작게 나눈 뒤 판매한다. 경영진은 이익이 최대가 되도록 막대를 자르는 방법을 알고 싶어한다. 회사에서 구매한 n인치의 강철 막대에서 이익이 최대가 되도록 막대를 자르는 알고리즘을 작성하라.
<추가 정보> 막대를 자르는데 비용이 들지는 않는다.
최적해는 강철 막대를 자르지 않는 것일 수도 있다.
<기호 설명> i = 1, 2, 3... 에 대해 길이 i인치 막대에 대해서 달러로 가격 Pi를 청구한다고 가정한다. 아래와 같은 예시로 가격이 붙을 수 있다.
길이 i	1	2	3	4	5	6	7	8	9	10
가격 Pi	1	5	8	9	10	17	17	20	24	30

<풀이>
만약 n이 4라고 가정하자. 이 경우 자를 수 있는 방법은 아래와 같이 표현 가능하다.
길이 배열	[4]	[1,3]	[2, 2]	[3, 1]	[1, 1, 2]	[1, 2, 1]	[2, 1, 1]	[1, 1, 1, 1]
가격	9	1, 8	5, 5	8, 1	1, 1, 5	1, 5, 1	5, 1, 1	1, 1, 1, 1
즉 4인치의 막대는 2인치 막대 두 개로 만들면 가장 큰 이윤(10)을 얻을 수 있는 것이다.

길이가 n인 막대는 2^(n-1)개의 다른 방법으로 나눌 수 있는데, 1~n-1까지 각 인치마다 자르거나 자르지 않는 것을 '선택'할 수 있기 때문이다.

보통 덧셈 개념을 통해 조각의 분해를 나타낸다. 예를 들어 7 = 2+2+3은 길이가 7인 막대를 2 두 조각, 3 한 조각으로 나누었음을 나타낸다. 최적해가 막대를 1 ≤ k ≤n에 대해 k 개의 조각으로 나누면, 막대를 i_1,i_2,i_3....,i_k로 나누는 다음의 최적의 분해는 n = i_1+i_2+i_3....+i_k로 나타낼 수 있고 최대의 수익은 r_n= 〖Pi〗_1+〖Pi〗_2+〖Pi〗_3....+〖Pi〗_k로 나타낼 수 있다.

이제 i=1,2,3.....10에 대한 최적의 수익 r_i의 최적의 분해를 구하는 방법은 다음과 같다.

r_1  = 1 1 = 1 (자르지 않음)
r_2  = 5 2 = 2 (자르지 않음)
r_3  = 8 3 = 3 (자르지 않음)
r_4  = 10 4 = 2+2 분해로부터
r_5  = 13 5 = 2+3 분해로부터
r_6  = 17 6 = 6 (자르지 않음)
r_7  = 18 7 = 1+6 또는 7 = 2+2+3 분해로부터
r_8  = 22 8 = 2+6 분해로부터
r_9  = 25 9 = 3+6 분해로부터
r_10  = 30 10 = 10 (자르지 않음)

즉 n ≥ 1일 때 r_n값을 알고 싶다면 더 작은 막대로부터 최대 수익을 얻음으로써 나타낼 수 있다.

r_n= max(p_n,r_1  + p_(n-1),r_2  + r_(n-2)  ...,r_(n-1)  + r_1)

p_n은 자르지 않고 길이가 n인 그대로 막대를 파는 것을 말한다. p_(n-1) 에서는 길이 i 와 n-i 둘로 나누고 두 조각을 더 최적으로 잘라 r_i와 r_(n-i)의 수익을 얻는 것 중 최대 수익을 구한다. 여기서 최대 수익을 얻는 i를 얻기 위해서는 가능한 모든 i 값을 고려해서 수익을 최대로 하는 값을 뽑아야 한다. 다시 한번 얘기하지만 막대를 자르지 않고 그대로 파는 것이 수익이 더 크다면 i 를 선택하지 않아도 된다.

크기가 n인 원래 문제를 풀기 위해 종류가 같은 더 작은 크기의 문제를 푼다. 첫 번쨰 자르기 후 두 조각을 막대 자르기 독립 문제로 여겨도 좋다. 그렇기 때문에 막대 자르기 문제는 최적 부분구조(Optimal Substructure)를 가졌다고 한다. 하나의 문제에 대한 최적해는 각각을 독립적으로 풀 수 있는 연관된 부분 문제들의 최적해를 이용한다.

막대 자르기 문제를 재귀 구조로 만드는 좀 더 간단한 방법은 맨 왼쪽 끝부터 길이가 i인 첫번째 조각과 길이가 n-i인 오른쪽 나머지 조각으로 나누는 것이다. 이때 첫 번째 조각을 제외한 나머지를 더 분해할 수 있다. 따라서 길이가 n인 막대의 모든 분해를 이런 식으로 첫 번째 조각과 나머지의 어떤 분해로 볼 수 있다. 자르지 않는 방법은 p_n과 r_0(=p_0)을 통해 계산할 수 있다. 그러므로 다음의 계산식으로 표현 가능하다.

r_n=   max┬(1≤i≤n)⁡  (p_i+r_(n-i))

이 공식에서 최적해는 두 개보다는 단 한 개의 관련된 부분문제만 가지고 만든다.

<Swift 구현>

우선 간단한 구현이다.

```swift
func cutRod(p: [Int], n: Int) {
    guard n != 0 else {
    return 0
}

var result = 0
for i in 1...n {
    result = max(result, p[i] + cutRod(p, n - i))
    }

return result
}
```

재귀를 이용한 풀이이다. 하지만, 이는 최적 부분해를 저장하지 않고 있다.

Reference:
Introduction to Algorithms (3rd Edition) - 15장 동적 프로그래밍
